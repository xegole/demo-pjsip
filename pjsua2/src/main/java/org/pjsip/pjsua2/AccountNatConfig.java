/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.4.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.pjsip.pjsua2;

/**
 * Account's NAT (Network Address Translation) settings. This will be<br>
 * specified in AccountConfig.
 */
public class AccountNatConfig extends PersistentObject {
  private transient long swigCPtr;

  protected AccountNatConfig(long cPtr, boolean cMemoryOwn) {
    super(pjsua2JNI.AccountNatConfig_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(AccountNatConfig obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected static long swigRelease(AccountNatConfig obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        pjsua2JNI.delete_AccountNatConfig(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  /**
   * Control the use of STUN for the SIP signaling.<br>
   * <br>
   * Default: PJSUA_STUN_USE_DEFAULT
   */
  public void setSipStunUse(int value) {
    pjsua2JNI.AccountNatConfig_sipStunUse_set(swigCPtr, this, value);
  }

  /**
   * Control the use of STUN for the SIP signaling.<br>
   * <br>
   * Default: PJSUA_STUN_USE_DEFAULT
   */
  public int getSipStunUse() {
    return pjsua2JNI.AccountNatConfig_sipStunUse_get(swigCPtr, this);
  }

  /**
   * Control the use of STUN for the media transports.<br>
   * <br>
   * Default: PJSUA_STUN_USE_DEFAULT
   */
  public void setMediaStunUse(int value) {
    pjsua2JNI.AccountNatConfig_mediaStunUse_set(swigCPtr, this, value);
  }

  /**
   * Control the use of STUN for the media transports.<br>
   * <br>
   * Default: PJSUA_STUN_USE_DEFAULT
   */
  public int getMediaStunUse() {
    return pjsua2JNI.AccountNatConfig_mediaStunUse_get(swigCPtr, this);
  }

  /**
   * Control the use of UPnP for the SIP signaling.<br>
   * <br>
   * Default: PJSUA_UPNP_USE_DEFAULT
   */
  public void setSipUpnpUse(int value) {
    pjsua2JNI.AccountNatConfig_sipUpnpUse_set(swigCPtr, this, value);
  }

  /**
   * Control the use of UPnP for the SIP signaling.<br>
   * <br>
   * Default: PJSUA_UPNP_USE_DEFAULT
   */
  public int getSipUpnpUse() {
    return pjsua2JNI.AccountNatConfig_sipUpnpUse_get(swigCPtr, this);
  }

  /**
   * Control the use of UPnP for the media transports.<br>
   * <br>
   * Default: PJSUA_UPNP_USE_DEFAULT
   */
  public void setMediaUpnpUse(int value) {
    pjsua2JNI.AccountNatConfig_mediaUpnpUse_set(swigCPtr, this, value);
  }

  /**
   * Control the use of UPnP for the media transports.<br>
   * <br>
   * Default: PJSUA_UPNP_USE_DEFAULT
   */
  public int getMediaUpnpUse() {
    return pjsua2JNI.AccountNatConfig_mediaUpnpUse_get(swigCPtr, this);
  }

  /**
   * Specify NAT64 options.<br>
   * <br>
   * Default: PJSUA_NAT64_DISABLED
   */
  public void setNat64Opt(int value) {
    pjsua2JNI.AccountNatConfig_nat64Opt_set(swigCPtr, this, value);
  }

  /**
   * Specify NAT64 options.<br>
   * <br>
   * Default: PJSUA_NAT64_DISABLED
   */
  public int getNat64Opt() {
    return pjsua2JNI.AccountNatConfig_nat64Opt_get(swigCPtr, this);
  }

  /**
   * Enable ICE for the media transport.<br>
   * <br>
   * Default: False
   */
  public void setIceEnabled(boolean value) {
    pjsua2JNI.AccountNatConfig_iceEnabled_set(swigCPtr, this, value);
  }

  /**
   * Enable ICE for the media transport.<br>
   * <br>
   * Default: False
   */
  public boolean getIceEnabled() {
    return pjsua2JNI.AccountNatConfig_iceEnabled_get(swigCPtr, this);
  }

  /**
   * Set trickle ICE mode for ICE media transport.<br>
   * <br>
   * Default: PJ_ICE_SESS_TRICKLE_DISABLED
   */
  public void setIceTrickle(int value) {
    pjsua2JNI.AccountNatConfig_iceTrickle_set(swigCPtr, this, value);
  }

  /**
   * Set trickle ICE mode for ICE media transport.<br>
   * <br>
   * Default: PJ_ICE_SESS_TRICKLE_DISABLED
   */
  public int getIceTrickle() {
    return pjsua2JNI.AccountNatConfig_iceTrickle_get(swigCPtr, this);
  }

  /**
   * Set the maximum number of ICE host candidates.<br>
   * <br>
   * Default: -1 (maximum not set)
   */
  public void setIceMaxHostCands(int value) {
    pjsua2JNI.AccountNatConfig_iceMaxHostCands_set(swigCPtr, this, value);
  }

  /**
   * Set the maximum number of ICE host candidates.<br>
   * <br>
   * Default: -1 (maximum not set)
   */
  public int getIceMaxHostCands() {
    return pjsua2JNI.AccountNatConfig_iceMaxHostCands_get(swigCPtr, this);
  }

  /**
   * Optional configuration to manually specify host candidates.<br>
   * Each candidate will use the same port as the automatic/base host<br>
   * candidate. The number of entries in this array must be equal or less<br>
   * than <i>iceMaxHostCands</i>.
   */
  public void setIceManualHost(StringVector value) {
    pjsua2JNI.AccountNatConfig_iceManualHost_set(swigCPtr, this, StringVector.getCPtr(value), value);
  }

  /**
   * Optional configuration to manually specify host candidates.<br>
   * Each candidate will use the same port as the automatic/base host<br>
   * candidate. The number of entries in this array must be equal or less<br>
   * than <i>iceMaxHostCands</i>.
   */
  public StringVector getIceManualHost() {
    long cPtr = pjsua2JNI.AccountNatConfig_iceManualHost_get(swigCPtr, this);
    return (cPtr == 0) ? null : new StringVector(cPtr, false);
  }

  /**
   * Specify whether to use aggressive nomination.<br>
   * <br>
   * Default: True
   */
  public void setIceAggressiveNomination(boolean value) {
    pjsua2JNI.AccountNatConfig_iceAggressiveNomination_set(swigCPtr, this, value);
  }

  /**
   * Specify whether to use aggressive nomination.<br>
   * <br>
   * Default: True
   */
  public boolean getIceAggressiveNomination() {
    return pjsua2JNI.AccountNatConfig_iceAggressiveNomination_get(swigCPtr, this);
  }

  /**
   * For controlling agent if it uses regular nomination, specify the delay<br>
   * to perform nominated check (connectivity check with USE-CANDIDATE<br>
   * attribute) after all components have a valid pair.<br>
   * <br>
   * Default value is PJ_ICE_NOMINATED_CHECK_DELAY.
   */
  public void setIceNominatedCheckDelayMsec(long value) {
    pjsua2JNI.AccountNatConfig_iceNominatedCheckDelayMsec_set(swigCPtr, this, value);
  }

  /**
   * For controlling agent if it uses regular nomination, specify the delay<br>
   * to perform nominated check (connectivity check with USE-CANDIDATE<br>
   * attribute) after all components have a valid pair.<br>
   * <br>
   * Default value is PJ_ICE_NOMINATED_CHECK_DELAY.
   */
  public long getIceNominatedCheckDelayMsec() {
    return pjsua2JNI.AccountNatConfig_iceNominatedCheckDelayMsec_get(swigCPtr, this);
  }

  /**
   * For a controlled agent, specify how long it wants to wait (in<br>
   * milliseconds) for the controlling agent to complete sending<br>
   * connectivity check with nominated flag set to true for all components<br>
   * after the controlled agent has found that all connectivity checks in<br>
   * its checklist have been completed and there is at least one successful<br>
   * (but not nominated) check for every component.<br>
   * <br>
   * Default value for this option is<br>
   * ICE_CONTROLLED_AGENT_WAIT_NOMINATION_TIMEOUT. Specify -1 to disable<br>
   * this timer.
   */
  public void setIceWaitNominationTimeoutMsec(int value) {
    pjsua2JNI.AccountNatConfig_iceWaitNominationTimeoutMsec_set(swigCPtr, this, value);
  }

  /**
   * For a controlled agent, specify how long it wants to wait (in<br>
   * milliseconds) for the controlling agent to complete sending<br>
   * connectivity check with nominated flag set to true for all components<br>
   * after the controlled agent has found that all connectivity checks in<br>
   * its checklist have been completed and there is at least one successful<br>
   * (but not nominated) check for every component.<br>
   * <br>
   * Default value for this option is<br>
   * ICE_CONTROLLED_AGENT_WAIT_NOMINATION_TIMEOUT. Specify -1 to disable<br>
   * this timer.
   */
  public int getIceWaitNominationTimeoutMsec() {
    return pjsua2JNI.AccountNatConfig_iceWaitNominationTimeoutMsec_get(swigCPtr, this);
  }

  /**
   * Specify whether to check the source address of the incoming messages.<br>
   * The source address will be compared to the remote candidate which has<br>
   * a completed connectivity check or received a connectivity check.<br>
   * <br>
   * Default value is PJ_ICE_SESS_CHECK_SRC_ADDR.
   */
  public void setIceCheckSrcAddr(long value) {
    pjsua2JNI.AccountNatConfig_iceCheckSrcAddr_set(swigCPtr, this, value);
  }

  /**
   * Specify whether to check the source address of the incoming messages.<br>
   * The source address will be compared to the remote candidate which has<br>
   * a completed connectivity check or received a connectivity check.<br>
   * <br>
   * Default value is PJ_ICE_SESS_CHECK_SRC_ADDR.
   */
  public long getIceCheckSrcAddr() {
    return pjsua2JNI.AccountNatConfig_iceCheckSrcAddr_get(swigCPtr, this);
  }

  /**
   * Disable RTCP component.<br>
   * <br>
   * Default: False
   */
  public void setIceNoRtcp(boolean value) {
    pjsua2JNI.AccountNatConfig_iceNoRtcp_set(swigCPtr, this, value);
  }

  /**
   * Disable RTCP component.<br>
   * <br>
   * Default: False
   */
  public boolean getIceNoRtcp() {
    return pjsua2JNI.AccountNatConfig_iceNoRtcp_get(swigCPtr, this);
  }

  /**
   * Always send re-INVITE/UPDATE after ICE negotiation regardless of whether<br>
   * the default ICE transport address is changed or not. When this is set<br>
   * to False, re-INVITE/UPDATE will be sent only when the default ICE<br>
   * transport address is changed.<br>
   * <br>
   * Default: yes
   */
  public void setIceAlwaysUpdate(boolean value) {
    pjsua2JNI.AccountNatConfig_iceAlwaysUpdate_set(swigCPtr, this, value);
  }

  /**
   * Always send re-INVITE/UPDATE after ICE negotiation regardless of whether<br>
   * the default ICE transport address is changed or not. When this is set<br>
   * to False, re-INVITE/UPDATE will be sent only when the default ICE<br>
   * transport address is changed.<br>
   * <br>
   * Default: yes
   */
  public boolean getIceAlwaysUpdate() {
    return pjsua2JNI.AccountNatConfig_iceAlwaysUpdate_get(swigCPtr, this);
  }

  /**
   * Enable TURN candidate in ICE.
   */
  public void setTurnEnabled(boolean value) {
    pjsua2JNI.AccountNatConfig_turnEnabled_set(swigCPtr, this, value);
  }

  /**
   * Enable TURN candidate in ICE.
   */
  public boolean getTurnEnabled() {
    return pjsua2JNI.AccountNatConfig_turnEnabled_get(swigCPtr, this);
  }

  /**
   * Specify TURN domain name or host name, in in "DOMAIN:PORT" or<br>
   * "HOST:PORT" format.
   */
  public void setTurnServer(String value) {
    pjsua2JNI.AccountNatConfig_turnServer_set(swigCPtr, this, value);
  }

  /**
   * Specify TURN domain name or host name, in in "DOMAIN:PORT" or<br>
   * "HOST:PORT" format.
   */
  public String getTurnServer() {
    return pjsua2JNI.AccountNatConfig_turnServer_get(swigCPtr, this);
  }

  /**
   * Specify the connection type to be used to the TURN server. Valid<br>
   * values are PJ_TURN_TP_UDP or PJ_TURN_TP_TCP.<br>
   * <br>
   * Default: PJ_TURN_TP_UDP
   */
  public void setTurnConnType(int value) {
    pjsua2JNI.AccountNatConfig_turnConnType_set(swigCPtr, this, value);
  }

  /**
   * Specify the connection type to be used to the TURN server. Valid<br>
   * values are PJ_TURN_TP_UDP or PJ_TURN_TP_TCP.<br>
   * <br>
   * Default: PJ_TURN_TP_UDP
   */
  public int getTurnConnType() {
    return pjsua2JNI.AccountNatConfig_turnConnType_get(swigCPtr, this);
  }

  /**
   * Specify the username to authenticate with the TURN server.
   */
  public void setTurnUserName(String value) {
    pjsua2JNI.AccountNatConfig_turnUserName_set(swigCPtr, this, value);
  }

  /**
   * Specify the username to authenticate with the TURN server.
   */
  public String getTurnUserName() {
    return pjsua2JNI.AccountNatConfig_turnUserName_get(swigCPtr, this);
  }

  /**
   * Specify the type of password. Currently this must be zero to<br>
   * indicate plain-text password will be used in the password.
   */
  public void setTurnPasswordType(int value) {
    pjsua2JNI.AccountNatConfig_turnPasswordType_set(swigCPtr, this, value);
  }

  /**
   * Specify the type of password. Currently this must be zero to<br>
   * indicate plain-text password will be used in the password.
   */
  public int getTurnPasswordType() {
    return pjsua2JNI.AccountNatConfig_turnPasswordType_get(swigCPtr, this);
  }

  /**
   * Specify the password to authenticate with the TURN server.
   */
  public void setTurnPassword(String value) {
    pjsua2JNI.AccountNatConfig_turnPassword_set(swigCPtr, this, value);
  }

  /**
   * Specify the password to authenticate with the TURN server.
   */
  public String getTurnPassword() {
    return pjsua2JNI.AccountNatConfig_turnPassword_get(swigCPtr, this);
  }

  /**
   * This option is used to update the transport address and the Contact<br>
   * header of REGISTER request. When this option is  enabled, the library<br>
   * will keep track of the public IP address from the response of REGISTER<br>
   * request. Once it detects that the address has changed, it will<br>
   * unregister current Contact, update the Contact with transport address<br>
   * learned from Via header, and register a new Contact to the registrar.<br>
   * This will also update the public name of UDP transport if STUN is<br>
   * configured.<br>
   * <br>
   * Possible values:<br>
   * * 0 (disabled).<br>
   * * 1 (enabled). Update except if both Contact and server's IP address<br>
   * are public but response contains private IP.<br>
   * * 2 (enabled). Update without exception.<br>
   * <br>
   * See also contactRewriteMethod field.<br>
   * <br>
   * Default: 1
   */
  public void setContactRewriteUse(int value) {
    pjsua2JNI.AccountNatConfig_contactRewriteUse_set(swigCPtr, this, value);
  }

  /**
   * This option is used to update the transport address and the Contact<br>
   * header of REGISTER request. When this option is  enabled, the library<br>
   * will keep track of the public IP address from the response of REGISTER<br>
   * request. Once it detects that the address has changed, it will<br>
   * unregister current Contact, update the Contact with transport address<br>
   * learned from Via header, and register a new Contact to the registrar.<br>
   * This will also update the public name of UDP transport if STUN is<br>
   * configured.<br>
   * <br>
   * Possible values:<br>
   * * 0 (disabled).<br>
   * * 1 (enabled). Update except if both Contact and server's IP address<br>
   * are public but response contains private IP.<br>
   * * 2 (enabled). Update without exception.<br>
   * <br>
   * See also contactRewriteMethod field.<br>
   * <br>
   * Default: 1
   */
  public int getContactRewriteUse() {
    return pjsua2JNI.AccountNatConfig_contactRewriteUse_get(swigCPtr, this);
  }

  /**
   * Specify how Contact update will be done with the registration, if<br>
   * <i>contactRewriteEnabled</i> is enabled. The value is bitmask combination of<br>
   * <i>pjsua_contact_rewrite_method</i>. See also pjsua_contact_rewrite_method.<br>
   * <br>
   * Value PJSUA_CONTACT_REWRITE_UNREGISTER(1) is the legacy behavior.<br>
   * <br>
   * Default value: PJSUA_CONTACT_REWRITE_METHOD<br>
   *   (PJSUA_CONTACT_REWRITE_NO_UNREG | PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE)
   */
  public void setContactRewriteMethod(int value) {
    pjsua2JNI.AccountNatConfig_contactRewriteMethod_set(swigCPtr, this, value);
  }

  /**
   * Specify how Contact update will be done with the registration, if<br>
   * <i>contactRewriteEnabled</i> is enabled. The value is bitmask combination of<br>
   * <i>pjsua_contact_rewrite_method</i>. See also pjsua_contact_rewrite_method.<br>
   * <br>
   * Value PJSUA_CONTACT_REWRITE_UNREGISTER(1) is the legacy behavior.<br>
   * <br>
   * Default value: PJSUA_CONTACT_REWRITE_METHOD<br>
   *   (PJSUA_CONTACT_REWRITE_NO_UNREG | PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE)
   */
  public int getContactRewriteMethod() {
    return pjsua2JNI.AccountNatConfig_contactRewriteMethod_get(swigCPtr, this);
  }

  /**
   * Specify if source TCP port should be used as the initial Contact<br>
   * address if TCP/TLS transport is used. Note that this feature will<br>
   * be automatically turned off when nameserver is configured because<br>
   * it may yield different destination address due to DNS SRV resolution.<br>
   * Also some platforms are unable to report the local address of the<br>
   * TCP socket when it is still connecting. In these cases, this<br>
   * feature will also be turned off.<br>
   * <br>
   * Default: 1 (PJ_TRUE / yes).
   */
  public void setContactUseSrcPort(int value) {
    pjsua2JNI.AccountNatConfig_contactUseSrcPort_set(swigCPtr, this, value);
  }

  /**
   * Specify if source TCP port should be used as the initial Contact<br>
   * address if TCP/TLS transport is used. Note that this feature will<br>
   * be automatically turned off when nameserver is configured because<br>
   * it may yield different destination address due to DNS SRV resolution.<br>
   * Also some platforms are unable to report the local address of the<br>
   * TCP socket when it is still connecting. In these cases, this<br>
   * feature will also be turned off.<br>
   * <br>
   * Default: 1 (PJ_TRUE / yes).
   */
  public int getContactUseSrcPort() {
    return pjsua2JNI.AccountNatConfig_contactUseSrcPort_get(swigCPtr, this);
  }

  /**
   * This option is used to overwrite the "sent-by" field of the Via header<br>
   * for outgoing messages with the same interface address as the one in<br>
   * the REGISTER request, as long as the request uses the same transport<br>
   * instance as the previous REGISTER request.<br>
   * <br>
   * Default: 1 (PJ_TRUE / yes)
   */
  public void setViaRewriteUse(int value) {
    pjsua2JNI.AccountNatConfig_viaRewriteUse_set(swigCPtr, this, value);
  }

  /**
   * This option is used to overwrite the "sent-by" field of the Via header<br>
   * for outgoing messages with the same interface address as the one in<br>
   * the REGISTER request, as long as the request uses the same transport<br>
   * instance as the previous REGISTER request.<br>
   * <br>
   * Default: 1 (PJ_TRUE / yes)
   */
  public int getViaRewriteUse() {
    return pjsua2JNI.AccountNatConfig_viaRewriteUse_get(swigCPtr, this);
  }

  /**
   * This option controls whether the IP address in SDP should be replaced<br>
   * with the IP address found in Via header of the REGISTER response, ONLY<br>
   * when STUN and ICE are not used. If the value is FALSE (the original<br>
   * behavior), then the local IP address will be used. If TRUE, and when<br>
   * STUN and ICE are disabled, then the IP address found in registration<br>
   * response will be used.<br>
   * <br>
   * Default: PJ_FALSE (no)
   */
  public void setSdpNatRewriteUse(int value) {
    pjsua2JNI.AccountNatConfig_sdpNatRewriteUse_set(swigCPtr, this, value);
  }

  /**
   * This option controls whether the IP address in SDP should be replaced<br>
   * with the IP address found in Via header of the REGISTER response, ONLY<br>
   * when STUN and ICE are not used. If the value is FALSE (the original<br>
   * behavior), then the local IP address will be used. If TRUE, and when<br>
   * STUN and ICE are disabled, then the IP address found in registration<br>
   * response will be used.<br>
   * <br>
   * Default: PJ_FALSE (no)
   */
  public int getSdpNatRewriteUse() {
    return pjsua2JNI.AccountNatConfig_sdpNatRewriteUse_get(swigCPtr, this);
  }

  /**
   * Control the use of SIP outbound feature. SIP outbound is described in<br>
   * RFC 5626 to enable proxies or registrar to send inbound requests back<br>
   * to UA using the same connection initiated by the UA for its<br>
   * registration. This feature is highly useful in NAT-ed deployemtns,<br>
   * hence it is enabled by default.<br>
   * <br>
   * Note: currently SIP outbound can only be used with TCP and TLS<br>
   * transports. If UDP is used for the registration, the SIP outbound<br>
   * feature will be silently ignored for the account.<br>
   * <br>
   * Default: 1 (PJ_TRUE / yes)
   */
  public void setSipOutboundUse(int value) {
    pjsua2JNI.AccountNatConfig_sipOutboundUse_set(swigCPtr, this, value);
  }

  /**
   * Control the use of SIP outbound feature. SIP outbound is described in<br>
   * RFC 5626 to enable proxies or registrar to send inbound requests back<br>
   * to UA using the same connection initiated by the UA for its<br>
   * registration. This feature is highly useful in NAT-ed deployemtns,<br>
   * hence it is enabled by default.<br>
   * <br>
   * Note: currently SIP outbound can only be used with TCP and TLS<br>
   * transports. If UDP is used for the registration, the SIP outbound<br>
   * feature will be silently ignored for the account.<br>
   * <br>
   * Default: 1 (PJ_TRUE / yes)
   */
  public int getSipOutboundUse() {
    return pjsua2JNI.AccountNatConfig_sipOutboundUse_get(swigCPtr, this);
  }

  /**
   * Specify SIP outbound (RFC 5626) instance ID to be used by this<br>
   * account. If empty, an instance ID will be generated based on<br>
   * the hostname of this agent. If application specifies this parameter, the<br>
   * value will look like "<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>"<br>
   * without the double-quotes.<br>
   * <br>
   * Default: empty
   */
  public void setSipOutboundInstanceId(String value) {
    pjsua2JNI.AccountNatConfig_sipOutboundInstanceId_set(swigCPtr, this, value);
  }

  /**
   * Specify SIP outbound (RFC 5626) instance ID to be used by this<br>
   * account. If empty, an instance ID will be generated based on<br>
   * the hostname of this agent. If application specifies this parameter, the<br>
   * value will look like "<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>"<br>
   * without the double-quotes.<br>
   * <br>
   * Default: empty
   */
  public String getSipOutboundInstanceId() {
    return pjsua2JNI.AccountNatConfig_sipOutboundInstanceId_get(swigCPtr, this);
  }

  /**
   * Specify SIP outbound (RFC 5626) registration ID. The default value<br>
   * is empty, which would cause the library to automatically generate<br>
   * a suitable value.<br>
   * <br>
   * Default: empty
   */
  public void setSipOutboundRegId(String value) {
    pjsua2JNI.AccountNatConfig_sipOutboundRegId_set(swigCPtr, this, value);
  }

  /**
   * Specify SIP outbound (RFC 5626) registration ID. The default value<br>
   * is empty, which would cause the library to automatically generate<br>
   * a suitable value.<br>
   * <br>
   * Default: empty
   */
  public String getSipOutboundRegId() {
    return pjsua2JNI.AccountNatConfig_sipOutboundRegId_get(swigCPtr, this);
  }

  /**
   * Set the interval for periodic keep-alive transmission for this account.<br>
   * If this value is zero, keep-alive will be disabled for this account.<br>
   * The keep-alive transmission will be sent to the registrar's address,<br>
   * after successful registration.<br>
   * <br>
   * Default: 15 (seconds)
   */
  public void setUdpKaIntervalSec(long value) {
    pjsua2JNI.AccountNatConfig_udpKaIntervalSec_set(swigCPtr, this, value);
  }

  /**
   * Set the interval for periodic keep-alive transmission for this account.<br>
   * If this value is zero, keep-alive will be disabled for this account.<br>
   * The keep-alive transmission will be sent to the registrar's address,<br>
   * after successful registration.<br>
   * <br>
   * Default: 15 (seconds)
   */
  public long getUdpKaIntervalSec() {
    return pjsua2JNI.AccountNatConfig_udpKaIntervalSec_get(swigCPtr, this);
  }

  /**
   * Specify the data to be transmitted as keep-alive packets.<br>
   * <br>
   * Default: CR-LF
   */
  public void setUdpKaData(String value) {
    pjsua2JNI.AccountNatConfig_udpKaData_set(swigCPtr, this, value);
  }

  /**
   * Specify the data to be transmitted as keep-alive packets.<br>
   * <br>
   * Default: CR-LF
   */
  public String getUdpKaData() {
    return pjsua2JNI.AccountNatConfig_udpKaData_get(swigCPtr, this);
  }

  /**
   * Default constructor
   */
  public AccountNatConfig() {
    this(pjsua2JNI.new_AccountNatConfig(), true);
  }

  /**
   * Read this object from a container node.<br>
   * <br>
   * @param node              Container to read values from.
   */
  public void readObject(ContainerNode node) throws java.lang.Exception {
    pjsua2JNI.AccountNatConfig_readObject(swigCPtr, this, ContainerNode.getCPtr(node), node);
  }

  /**
   * Write this object to a container node.<br>
   * <br>
   * @param node              Container to write values to.
   */
  public void writeObject(ContainerNode node) throws java.lang.Exception {
    pjsua2JNI.AccountNatConfig_writeObject(swigCPtr, this, ContainerNode.getCPtr(node), node);
  }

}
