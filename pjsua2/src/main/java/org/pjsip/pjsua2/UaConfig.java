/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.4.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.pjsip.pjsua2;

/**
 * SIP User Agent related settings.
 */
public class UaConfig extends PersistentObject {
  private transient long swigCPtr;

  protected UaConfig(long cPtr, boolean cMemoryOwn) {
    super(pjsua2JNI.UaConfig_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(UaConfig obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected static long swigRelease(UaConfig obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        pjsua2JNI.delete_UaConfig(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  /**
   * Maximum calls to support (default: 4). The value specified here<br>
   * must be smaller than the compile time maximum settings<br>
   * PJSUA_MAX_CALLS, which by default is 32. To increase this<br>
   * limit, the library must be recompiled with new PJSUA_MAX_CALLS<br>
   * value.
   */
  public void setMaxCalls(long value) {
    pjsua2JNI.UaConfig_maxCalls_set(swigCPtr, this, value);
  }

  /**
   * Maximum calls to support (default: 4). The value specified here<br>
   * must be smaller than the compile time maximum settings<br>
   * PJSUA_MAX_CALLS, which by default is 32. To increase this<br>
   * limit, the library must be recompiled with new PJSUA_MAX_CALLS<br>
   * value.
   */
  public long getMaxCalls() {
    return pjsua2JNI.UaConfig_maxCalls_get(swigCPtr, this);
  }

  /**
   * Number of worker threads. Normally application will want to have at<br>
   * least one worker thread, unless when it wants to poll the library<br>
   * periodically, which in this case the worker thread can be set to<br>
   * zero.
   */
  public void setThreadCnt(long value) {
    pjsua2JNI.UaConfig_threadCnt_set(swigCPtr, this, value);
  }

  /**
   * Number of worker threads. Normally application will want to have at<br>
   * least one worker thread, unless when it wants to poll the library<br>
   * periodically, which in this case the worker thread can be set to<br>
   * zero.
   */
  public long getThreadCnt() {
    return pjsua2JNI.UaConfig_threadCnt_get(swigCPtr, this);
  }

  /**
   * When this flag is non-zero, all callbacks that come from thread<br>
   * other than main thread will be posted to the main thread and<br>
   * to be executed by Endpoint::libHandleEvents() function. This<br>
   * includes the logging callback. Note that this will only work if<br>
   * threadCnt is set to zero and Endpoint::libHandleEvents() is<br>
   * performed by main thread. By default, the main thread is set<br>
   * from the thread that invoke Endpoint::libCreate()<br>
   * <br>
   * Default: false
   */
  public void setMainThreadOnly(boolean value) {
    pjsua2JNI.UaConfig_mainThreadOnly_set(swigCPtr, this, value);
  }

  /**
   * When this flag is non-zero, all callbacks that come from thread<br>
   * other than main thread will be posted to the main thread and<br>
   * to be executed by Endpoint::libHandleEvents() function. This<br>
   * includes the logging callback. Note that this will only work if<br>
   * threadCnt is set to zero and Endpoint::libHandleEvents() is<br>
   * performed by main thread. By default, the main thread is set<br>
   * from the thread that invoke Endpoint::libCreate()<br>
   * <br>
   * Default: false
   */
  public boolean getMainThreadOnly() {
    return pjsua2JNI.UaConfig_mainThreadOnly_get(swigCPtr, this);
  }

  /**
   * Array of nameservers to be used by the SIP resolver subsystem.<br>
   * The order of the name server specifies the priority (first name<br>
   * server will be used first, unless it is not reachable).
   */
  public void setNameserver(StringVector value) {
    pjsua2JNI.UaConfig_nameserver_set(swigCPtr, this, StringVector.getCPtr(value), value);
  }

  /**
   * Array of nameservers to be used by the SIP resolver subsystem.<br>
   * The order of the name server specifies the priority (first name<br>
   * server will be used first, unless it is not reachable).
   */
  public StringVector getNameserver() {
    long cPtr = pjsua2JNI.UaConfig_nameserver_get(swigCPtr, this);
    return (cPtr == 0) ? null : new StringVector(cPtr, false);
  }

  /**
   * Specify the URL of outbound proxies to visit for all outgoing requests.<br>
   * The outbound proxies will be used for all accounts, and it will<br>
   * be used to build the route set for outgoing requests. The final<br>
   * route set for outgoing requests will consists of the outbound proxies<br>
   * and the proxy configured in the account.
   */
  public void setOutboundProxies(StringVector value) {
    pjsua2JNI.UaConfig_outboundProxies_set(swigCPtr, this, StringVector.getCPtr(value), value);
  }

  /**
   * Specify the URL of outbound proxies to visit for all outgoing requests.<br>
   * The outbound proxies will be used for all accounts, and it will<br>
   * be used to build the route set for outgoing requests. The final<br>
   * route set for outgoing requests will consists of the outbound proxies<br>
   * and the proxy configured in the account.
   */
  public StringVector getOutboundProxies() {
    long cPtr = pjsua2JNI.UaConfig_outboundProxies_get(swigCPtr, this);
    return (cPtr == 0) ? null : new StringVector(cPtr, false);
  }

  /**
   * Optional user agent string (default empty). If it's empty, no<br>
   * User-Agent header will be sent with outgoing requests.
   */
  public void setUserAgent(String value) {
    pjsua2JNI.UaConfig_userAgent_set(swigCPtr, this, value);
  }

  /**
   * Optional user agent string (default empty). If it's empty, no<br>
   * User-Agent header will be sent with outgoing requests.
   */
  public String getUserAgent() {
    return pjsua2JNI.UaConfig_userAgent_get(swigCPtr, this);
  }

  /**
   * Array of STUN servers to try. The library will try to resolve and<br>
   * contact each of the STUN server entry until it finds one that is<br>
   * usable. Each entry may be a domain name, host name, IP address, and<br>
   * it may contain an optional port number. For example:<br>
   *  - "pjsip.org" (domain name)<br>
   *  - "sip.pjsip.org" (host name)<br>
   *  - "pjsip.org:33478" (domain name and a non-standard port number)<br>
   *  - "10.0.0.1:3478" (IP address and port number)<br>
   * <br>
   * When nameserver is configured in the <i>pjsua_config.nameserver</i> field,<br>
   * if entry is not an IP address, it will be resolved with DNS SRV<br>
   * resolution first, and it will fallback to use DNS A resolution if this<br>
   * fails. Port number may be specified even if the entry is a domain name,<br>
   * in case the DNS SRV resolution should fallback to a non-standard port.<br>
   * <br>
   * When nameserver is not configured, entries will be resolved with<br>
   * pj_gethostbyname() if it's not an IP address. Port number may be<br>
   * specified if the server is not listening in standard STUN port.
   */
  public void setStunServer(StringVector value) {
    pjsua2JNI.UaConfig_stunServer_set(swigCPtr, this, StringVector.getCPtr(value), value);
  }

  /**
   * Array of STUN servers to try. The library will try to resolve and<br>
   * contact each of the STUN server entry until it finds one that is<br>
   * usable. Each entry may be a domain name, host name, IP address, and<br>
   * it may contain an optional port number. For example:<br>
   *  - "pjsip.org" (domain name)<br>
   *  - "sip.pjsip.org" (host name)<br>
   *  - "pjsip.org:33478" (domain name and a non-standard port number)<br>
   *  - "10.0.0.1:3478" (IP address and port number)<br>
   * <br>
   * When nameserver is configured in the <i>pjsua_config.nameserver</i> field,<br>
   * if entry is not an IP address, it will be resolved with DNS SRV<br>
   * resolution first, and it will fallback to use DNS A resolution if this<br>
   * fails. Port number may be specified even if the entry is a domain name,<br>
   * in case the DNS SRV resolution should fallback to a non-standard port.<br>
   * <br>
   * When nameserver is not configured, entries will be resolved with<br>
   * pj_gethostbyname() if it's not an IP address. Port number may be<br>
   * specified if the server is not listening in standard STUN port.
   */
  public StringVector getStunServer() {
    long cPtr = pjsua2JNI.UaConfig_stunServer_get(swigCPtr, this);
    return (cPtr == 0) ? null : new StringVector(cPtr, false);
  }

  /**
   * This specifies if the library should try to do an IPv6 resolution of<br>
   * the STUN servers if the IPv4 resolution fails. It can be useful<br>
   * in an IPv6-only environment, including on NAT64.<br>
   * <br>
   * Default: FALSE
   */
  public void setStunTryIpv6(boolean value) {
    pjsua2JNI.UaConfig_stunTryIpv6_set(swigCPtr, this, value);
  }

  /**
   * This specifies if the library should try to do an IPv6 resolution of<br>
   * the STUN servers if the IPv4 resolution fails. It can be useful<br>
   * in an IPv6-only environment, including on NAT64.<br>
   * <br>
   * Default: FALSE
   */
  public boolean getStunTryIpv6() {
    return pjsua2JNI.UaConfig_stunTryIpv6_get(swigCPtr, this);
  }

  /**
   * This specifies if the library startup should ignore failure with the<br>
   * STUN servers. If this is set to PJ_FALSE, the library will refuse to<br>
   * start if it fails to resolve or contact any of the STUN servers.<br>
   * <br>
   * Default: TRUE
   */
  public void setStunIgnoreFailure(boolean value) {
    pjsua2JNI.UaConfig_stunIgnoreFailure_set(swigCPtr, this, value);
  }

  /**
   * This specifies if the library startup should ignore failure with the<br>
   * STUN servers. If this is set to PJ_FALSE, the library will refuse to<br>
   * start if it fails to resolve or contact any of the STUN servers.<br>
   * <br>
   * Default: TRUE
   */
  public boolean getStunIgnoreFailure() {
    return pjsua2JNI.UaConfig_stunIgnoreFailure_get(swigCPtr, this);
  }

  /**
   * Support for adding and parsing NAT type in the SDP to assist<br>
   * troubleshooting. The valid values are:<br>
   *  - 0: no information will be added in SDP, and parsing is disabled.<br>
   *  - 1: only the NAT type number is added.<br>
   *  - 2: add both NAT type number and name.<br>
   * <br>
   * Default: 1
   */
  public void setNatTypeInSdp(int value) {
    pjsua2JNI.UaConfig_natTypeInSdp_set(swigCPtr, this, value);
  }

  /**
   * Support for adding and parsing NAT type in the SDP to assist<br>
   * troubleshooting. The valid values are:<br>
   *  - 0: no information will be added in SDP, and parsing is disabled.<br>
   *  - 1: only the NAT type number is added.<br>
   *  - 2: add both NAT type number and name.<br>
   * <br>
   * Default: 1
   */
  public int getNatTypeInSdp() {
    return pjsua2JNI.UaConfig_natTypeInSdp_get(swigCPtr, this);
  }

  /**
   * Handle unsolicited NOTIFY requests containing message waiting<br>
   * indication (MWI) info. Unsolicited MWI is incoming NOTIFY requests<br>
   * which are not requested by client with SUBSCRIBE request.<br>
   * <br>
   * If this is enabled, the library will respond 200/OK to the NOTIFY<br>
   * request and forward the request to Endpoint::onMwiInfo() callback.<br>
   * <br>
   * Note: the callback will not be invoked and 481/"No account to handle" response<br>
   * will be sent if this is enabled but no account is configured.<br>
   * <br>
   * See also AccountMwiConfig.enabled.<br>
   * <br>
   * Default: PJ_TRUE
   */
  public void setMwiUnsolicitedEnabled(boolean value) {
    pjsua2JNI.UaConfig_mwiUnsolicitedEnabled_set(swigCPtr, this, value);
  }

  /**
   * Handle unsolicited NOTIFY requests containing message waiting<br>
   * indication (MWI) info. Unsolicited MWI is incoming NOTIFY requests<br>
   * which are not requested by client with SUBSCRIBE request.<br>
   * <br>
   * If this is enabled, the library will respond 200/OK to the NOTIFY<br>
   * request and forward the request to Endpoint::onMwiInfo() callback.<br>
   * <br>
   * Note: the callback will not be invoked and 481/"No account to handle" response<br>
   * will be sent if this is enabled but no account is configured.<br>
   * <br>
   * See also AccountMwiConfig.enabled.<br>
   * <br>
   * Default: PJ_TRUE
   */
  public boolean getMwiUnsolicitedEnabled() {
    return pjsua2JNI.UaConfig_mwiUnsolicitedEnabled_get(swigCPtr, this);
  }

  /**
   * Specify whether to enable UPnP.<br>
   * <br>
   * Note that this setting can be further customized in account<br>
   * configuration (#pjsua_acc_config).<br>
   * <br>
   * Default: FALSE
   */
  public void setEnableUpnp(boolean value) {
    pjsua2JNI.UaConfig_enableUpnp_set(swigCPtr, this, value);
  }

  /**
   * Specify whether to enable UPnP.<br>
   * <br>
   * Note that this setting can be further customized in account<br>
   * configuration (#pjsua_acc_config).<br>
   * <br>
   * Default: FALSE
   */
  public boolean getEnableUpnp() {
    return pjsua2JNI.UaConfig_enableUpnp_get(swigCPtr, this);
  }

  /**
   * Specify which interface to use for UPnP. If empty, UPnP will use<br>
   * the first suitable interface found.<br>
   * <br>
   * Note that this setting is only applicable if UPnP is enabled.<br>
   * <br>
   * Default: empty string
   */
  public void setUpnpIfName(String value) {
    pjsua2JNI.UaConfig_upnpIfName_set(swigCPtr, this, value);
  }

  /**
   * Specify which interface to use for UPnP. If empty, UPnP will use<br>
   * the first suitable interface found.<br>
   * <br>
   * Note that this setting is only applicable if UPnP is enabled.<br>
   * <br>
   * Default: empty string
   */
  public String getUpnpIfName() {
    return pjsua2JNI.UaConfig_upnpIfName_get(swigCPtr, this);
  }

  /**
   * Default constructor to initialize with default values.
   */
  public UaConfig() {
    this(pjsua2JNI.new_UaConfig(), true);
  }

  /**
   * Read this object from a container.<br>
   * <br>
   * @param node              Container to write values from.
   */
  public void readObject(ContainerNode node) throws java.lang.Exception {
    pjsua2JNI.UaConfig_readObject(swigCPtr, this, ContainerNode.getCPtr(node), node);
  }

  /**
   * Write this object to a container.<br>
   * <br>
   * @param node              Container to write values to.
   */
  public void writeObject(ContainerNode node) throws java.lang.Exception {
    pjsua2JNI.UaConfig_writeObject(swigCPtr, this, ContainerNode.getCPtr(node), node);
  }

}
