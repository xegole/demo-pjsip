/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.4.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.pjsip.pjsua2;

/**
 * Account media config (applicable for audio, video, and text). This will be<br>
 * specified in AccountConfig.
 */
public class AccountMediaConfig extends PersistentObject {
  private transient long swigCPtr;

  protected AccountMediaConfig(long cPtr, boolean cMemoryOwn) {
    super(pjsua2JNI.AccountMediaConfig_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(AccountMediaConfig obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected static long swigRelease(AccountMediaConfig obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        pjsua2JNI.delete_AccountMediaConfig(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  /**
   * Media transport (RTP) configuration.<br>
   * <br>
   * For <i>port</i> and <i>portRange</i> settings, RTCP port is selected as <br>
   * RTP port+1.<br>
   * Example: <i>port=5000</i>, <i>portRange=4</i><br>
   * - Available ports: 5000, 5002, 5004 (Media/RTP transport)<br>
   *                    5001, 5003, 5005 (Media/RTCP transport)
   */
  public void setTransportConfig(TransportConfig value) {
    pjsua2JNI.AccountMediaConfig_transportConfig_set(swigCPtr, this, TransportConfig.getCPtr(value), value);
  }

  /**
   * Media transport (RTP) configuration.<br>
   * <br>
   * For <i>port</i> and <i>portRange</i> settings, RTCP port is selected as <br>
   * RTP port+1.<br>
   * Example: <i>port=5000</i>, <i>portRange=4</i><br>
   * - Available ports: 5000, 5002, 5004 (Media/RTP transport)<br>
   *                    5001, 5003, 5005 (Media/RTCP transport)
   */
  public TransportConfig getTransportConfig() {
    long cPtr = pjsua2JNI.AccountMediaConfig_transportConfig_get(swigCPtr, this);
    return (cPtr == 0) ? null : new TransportConfig(cPtr, false);
  }

  /**
   * If remote sends SDP answer containing more than one format or codec in<br>
   * the media line, send re-INVITE or UPDATE with just one codec to lock<br>
   * which codec to use.<br>
   * <br>
   * Default: True (Yes).
   */
  public void setLockCodecEnabled(boolean value) {
    pjsua2JNI.AccountMediaConfig_lockCodecEnabled_set(swigCPtr, this, value);
  }

  /**
   * If remote sends SDP answer containing more than one format or codec in<br>
   * the media line, send re-INVITE or UPDATE with just one codec to lock<br>
   * which codec to use.<br>
   * <br>
   * Default: True (Yes).
   */
  public boolean getLockCodecEnabled() {
    return pjsua2JNI.AccountMediaConfig_lockCodecEnabled_get(swigCPtr, this);
  }

  /**
   * Specify whether stream keep-alive and NAT hole punching with<br>
   * non-codec-VAD mechanism (see PJMEDIA_STREAM_ENABLE_KA) is enabled<br>
   * for this account.<br>
   * <br>
   * Default: False
   */
  public void setStreamKaEnabled(boolean value) {
    pjsua2JNI.AccountMediaConfig_streamKaEnabled_set(swigCPtr, this, value);
  }

  /**
   * Specify whether stream keep-alive and NAT hole punching with<br>
   * non-codec-VAD mechanism (see PJMEDIA_STREAM_ENABLE_KA) is enabled<br>
   * for this account.<br>
   * <br>
   * Default: False
   */
  public boolean getStreamKaEnabled() {
    return pjsua2JNI.AccountMediaConfig_streamKaEnabled_get(swigCPtr, this);
  }

  /**
   * Specify whether secure media transport should be used for this account.<br>
   * Valid values are PJMEDIA_SRTP_DISABLED, PJMEDIA_SRTP_OPTIONAL, and<br>
   * PJMEDIA_SRTP_MANDATORY.<br>
   * <br>
   * Default: PJSUA_DEFAULT_USE_SRTP
   */
  public void setSrtpUse(int value) {
    pjsua2JNI.AccountMediaConfig_srtpUse_set(swigCPtr, this, value);
  }

  /**
   * Specify whether secure media transport should be used for this account.<br>
   * Valid values are PJMEDIA_SRTP_DISABLED, PJMEDIA_SRTP_OPTIONAL, and<br>
   * PJMEDIA_SRTP_MANDATORY.<br>
   * <br>
   * Default: PJSUA_DEFAULT_USE_SRTP
   */
  public int getSrtpUse() {
    return pjsua2JNI.AccountMediaConfig_srtpUse_get(swigCPtr, this);
  }

  /**
   * Specify whether SRTP requires secure signaling to be used. This option<br>
   * is only used when <i>use_srtp</i> option above is non-zero.<br>
   * <br>
   * Valid values are:<br>
   *  0: SRTP does not require secure signaling<br>
   *  1: SRTP requires secure transport such as TLS<br>
   *  2: SRTP requires secure end-to-end transport (SIPS)<br>
   * <br>
   * Default: PJSUA_DEFAULT_SRTP_SECURE_SIGNALING
   */
  public void setSrtpSecureSignaling(int value) {
    pjsua2JNI.AccountMediaConfig_srtpSecureSignaling_set(swigCPtr, this, value);
  }

  /**
   * Specify whether SRTP requires secure signaling to be used. This option<br>
   * is only used when <i>use_srtp</i> option above is non-zero.<br>
   * <br>
   * Valid values are:<br>
   *  0: SRTP does not require secure signaling<br>
   *  1: SRTP requires secure transport such as TLS<br>
   *  2: SRTP requires secure end-to-end transport (SIPS)<br>
   * <br>
   * Default: PJSUA_DEFAULT_SRTP_SECURE_SIGNALING
   */
  public int getSrtpSecureSignaling() {
    return pjsua2JNI.AccountMediaConfig_srtpSecureSignaling_get(swigCPtr, this);
  }

  /**
   * Specify SRTP settings, like cryptos and keying methods.
   */
  public void setSrtpOpt(SrtpOpt value) {
    pjsua2JNI.AccountMediaConfig_srtpOpt_set(swigCPtr, this, SrtpOpt.getCPtr(value), value);
  }

  /**
   * Specify SRTP settings, like cryptos and keying methods.
   */
  public SrtpOpt getSrtpOpt() {
    long cPtr = pjsua2JNI.AccountMediaConfig_srtpOpt_get(swigCPtr, this);
    return (cPtr == 0) ? null : new SrtpOpt(cPtr, false);
  }

  /**
   * Specify whether IPv6 should be used on media.<br>
   * <br>
   * Default: PJSUA_IPV6_ENABLED_PREFER_IPV4<br>
   * (Dual stack media, capable to use IPv4/IPv6.<br>
   * Outgoing offer will prefer to use IPv4)
   */
  public void setIpv6Use(int value) {
    pjsua2JNI.AccountMediaConfig_ipv6Use_set(swigCPtr, this, value);
  }

  /**
   * Specify whether IPv6 should be used on media.<br>
   * <br>
   * Default: PJSUA_IPV6_ENABLED_PREFER_IPV4<br>
   * (Dual stack media, capable to use IPv4/IPv6.<br>
   * Outgoing offer will prefer to use IPv4)
   */
  public int getIpv6Use() {
    return pjsua2JNI.AccountMediaConfig_ipv6Use_get(swigCPtr, this);
  }

  /**
   * Enable RTP and RTCP multiplexing.<br>
   * Default: false
   */
  public void setRtcpMuxEnabled(boolean value) {
    pjsua2JNI.AccountMediaConfig_rtcpMuxEnabled_set(swigCPtr, this, value);
  }

  /**
   * Enable RTP and RTCP multiplexing.<br>
   * Default: false
   */
  public boolean getRtcpMuxEnabled() {
    return pjsua2JNI.AccountMediaConfig_rtcpMuxEnabled_get(swigCPtr, this);
  }

  /**
   * RTCP Feedback settings.
   */
  public void setRtcpFbConfig(RtcpFbConfig value) {
    pjsua2JNI.AccountMediaConfig_rtcpFbConfig_set(swigCPtr, this, RtcpFbConfig.getCPtr(value), value);
  }

  /**
   * RTCP Feedback settings.
   */
  public RtcpFbConfig getRtcpFbConfig() {
    long cPtr = pjsua2JNI.AccountMediaConfig_rtcpFbConfig_get(swigCPtr, this);
    return (cPtr == 0) ? null : new RtcpFbConfig(cPtr, false);
  }

  /**
   * Enable RTCP Extended Report (RTCP XR).<br>
   * <br>
   * Default: PJMEDIA_STREAM_ENABLE_XR
   */
  public void setRtcpXrEnabled(boolean value) {
    pjsua2JNI.AccountMediaConfig_rtcpXrEnabled_set(swigCPtr, this, value);
  }

  /**
   * Enable RTCP Extended Report (RTCP XR).<br>
   * <br>
   * Default: PJMEDIA_STREAM_ENABLE_XR
   */
  public boolean getRtcpXrEnabled() {
    return pjsua2JNI.AccountMediaConfig_rtcpXrEnabled_get(swigCPtr, this);
  }

  /**
   * Use loopback media transport. This may be useful if application<br>
   * doesn't want PJSUA2 to create real media transports/sockets, such as<br>
   * when using third party media.<br>
   * <br>
   * Default: false
   */
  public void setUseLoopMedTp(boolean value) {
    pjsua2JNI.AccountMediaConfig_useLoopMedTp_set(swigCPtr, this, value);
  }

  /**
   * Use loopback media transport. This may be useful if application<br>
   * doesn't want PJSUA2 to create real media transports/sockets, such as<br>
   * when using third party media.<br>
   * <br>
   * Default: false
   */
  public boolean getUseLoopMedTp() {
    return pjsua2JNI.AccountMediaConfig_useLoopMedTp_get(swigCPtr, this);
  }

  /**
   * Enable local loopback when useLoopMedTp is set to TRUE.<br>
   * If enabled, packets sent to the transport will be sent back to<br>
   * the streams attached to the transport.<br>
   * <br>
   * Default: false
   */
  public void setEnableLoopback(boolean value) {
    pjsua2JNI.AccountMediaConfig_enableLoopback_set(swigCPtr, this, value);
  }

  /**
   * Enable local loopback when useLoopMedTp is set to TRUE.<br>
   * If enabled, packets sent to the transport will be sent back to<br>
   * the streams attached to the transport.<br>
   * <br>
   * Default: false
   */
  public boolean getEnableLoopback() {
    return pjsua2JNI.AccountMediaConfig_enableLoopback_get(swigCPtr, this);
  }

  /**
   * Default constructor
   */
  public AccountMediaConfig() {
    this(pjsua2JNI.new_AccountMediaConfig(), true);
  }

  /**
   * Read this object from a container node.<br>
   * <br>
   * @param node              Container to read values from.
   */
  public void readObject(ContainerNode node) throws java.lang.Exception {
    pjsua2JNI.AccountMediaConfig_readObject(swigCPtr, this, ContainerNode.getCPtr(node), node);
  }

  /**
   * Write this object to a container node.<br>
   * <br>
   * @param node              Container to write values to.
   */
  public void writeObject(ContainerNode node) throws java.lang.Exception {
    pjsua2JNI.AccountMediaConfig_writeObject(swigCPtr, this, ContainerNode.getCPtr(node), node);
  }

}
