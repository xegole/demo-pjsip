/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.4.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.pjsip.pjsua2;

/**
 * Audio Media. This is a lite wrapper class for audio conference bridge port,<br>
 * i.e: this class only maintains one data member, conference slot ID, and <br>
 * the methods are simply proxies for conference bridge operations.<br>
 * <br>
 * Application can create a derived class and use registerMediaPort2()/<br>
 * unregisterMediaPort() to register/unregister a media port to/from the<br>
 * conference bridge.<br>
 * <br>
 * The library will not keep a list of AudioMedia instances, so any<br>
 * AudioMedia (descendant) instances instantiated by application must be<br>
 * maintained and destroyed by the application itself.<br>
 * <br>
 * Note that any PJSUA2 APIs that return AudioMedia instance(s) such as<br>
 * Endpoint::mediaEnumPorts2() or Call::getAudioMedia() will just return<br>
 * generated copy. All AudioMedia methods should work normally on this<br>
 * generated copy instance.
 */
public class AudioMedia extends Media {
  private transient long swigCPtr;

  protected AudioMedia(long cPtr, boolean cMemoryOwn) {
    super(pjsua2JNI.AudioMedia_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(AudioMedia obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected static long swigRelease(AudioMedia obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        pjsua2JNI.delete_AudioMedia(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  /**
   * Get information about the specified conference port.
   */
  public ConfPortInfo getPortInfo() throws java.lang.Exception {
    return new ConfPortInfo(pjsua2JNI.AudioMedia_getPortInfo(swigCPtr, this), true);
  }

  /**
   * Get port Id.
   */
  public int getPortId() {
    return pjsua2JNI.AudioMedia_getPortId(swigCPtr, this);
  }

  /**
   * Get information from specific port id.
   */
  public static ConfPortInfo getPortInfoFromId(int port_id) throws java.lang.Exception {
    return new ConfPortInfo(pjsua2JNI.AudioMedia_getPortInfoFromId(port_id), true);
  }

  /**
   * Establish unidirectional media flow to sink. This media port<br>
   * will act as a source, and it may transmit to multiple destinations/sink.<br>
   * And if multiple sources are transmitting to the same sink, the media<br>
   * will be mixed together. Source and sink may refer to the same Media,<br>
   * effectively looping the media.<br>
   * <br>
   * If bidirectional media flow is desired, application needs to call<br>
   * this method twice, with the second one called from the opposite source<br>
   * media.<br>
   * <br>
   * This operation executes asynchronously, use the callback set from<br>
   * Endpoint::onAudioMediaOpCompleted() to receive notification upon<br>
   * completion.<br>
   * <br>
   * <br>
   * @param sink              The destination Media.
   */
  public void startTransmit(AudioMedia sink) throws java.lang.Exception {
    pjsua2JNI.AudioMedia_startTransmit(swigCPtr, this, AudioMedia.getCPtr(sink), sink);
  }

  /**
   * Establish unidirectional media flow to sink. This media port<br>
   * will act as a source, and it may transmit to multiple destinations/sink.<br>
   * And if multiple sources are transmitting to the same sink, the media<br>
   * will be mixed together. Source and sink may refer to the same Media,<br>
   * effectively looping the media.<br>
   * <br>
   * Signal level from this source to the sink can be adjusted by making<br>
   * it louder or quieter via the parameter param. The level adjustment<br>
   * will apply to a specific connection only (i.e. only for signal<br>
   * from this source to the sink), as compared to<br>
   * adjustTxLevel()/adjustRxLevel() which applies to all signals from/to<br>
   * this media port. The signal adjustment<br>
   * will be cumulative, in this following order:<br>
   * signal from this source will be adjusted with the level specified<br>
   * in adjustTxLevel(), then with the level specified via this API,<br>
   * and finally with the level specified to the sink's adjustRxLevel().<br>
   * <br>
   * If bidirectional media flow is desired, application needs to call<br>
   * this method twice, with the second one called from the opposite source<br>
   * media.<br>
   * <br>
   * This operation executes asynchronously, use the callback set from<br>
   * Endpoint::onAudioMediaOpCompleted() to receive notification upon<br>
   * completion.<br>
   * <br>
   * @param sink              The destination Media.<br>
   * @param param             The parameter.
   */
  public void startTransmit2(AudioMedia sink, AudioMediaTransmitParam param) throws java.lang.Exception {
    pjsua2JNI.AudioMedia_startTransmit2(swigCPtr, this, AudioMedia.getCPtr(sink), sink, AudioMediaTransmitParam.getCPtr(param), param);
  }

  /**
   *  Stop media flow to destination/sink port.<br>
   * <br>
   * This operation executes asynchronously, use the callback set from<br>
   * Endpoint::onAudioMediaOpCompleted() to receive notification upon<br>
   * completion.<br>
   * <br>
   * @param sink              The destination media.
   */
  public void stopTransmit(AudioMedia sink) throws java.lang.Exception {
    pjsua2JNI.AudioMedia_stopTransmit(swigCPtr, this, AudioMedia.getCPtr(sink), sink);
  }

  /**
   * Adjust the signal level to be transmitted from the bridge to this<br>
   * media port by making it louder or quieter.<br>
   * <br>
   * @param level             Signal level adjustment. Value 1.0 means no<br>
   *                          level adjustment, while value 0 means to mute<br>
   *                          the port.
   */
  public void adjustRxLevel(float level) throws java.lang.Exception {
    pjsua2JNI.AudioMedia_adjustRxLevel(swigCPtr, this, level);
  }

  /**
   * Adjust the signal level to be received from this media port (to<br>
   * the bridge) by making it louder or quieter.<br>
   * <br>
   * @param level             Signal level adjustment. Value 1.0 means no<br>
   *                          level adjustment, while value 0 means to mute<br>
   *                          the port.
   */
  public void adjustTxLevel(float level) throws java.lang.Exception {
    pjsua2JNI.AudioMedia_adjustTxLevel(swigCPtr, this, level);
  }

  /**
   * Get the last received signal level.<br>
   * <br>
   * @return Signal level in percent.
   */
  public long getRxLevel() throws java.lang.Exception {
    return pjsua2JNI.AudioMedia_getRxLevel(swigCPtr, this);
  }

  /**
   * Get the last transmitted signal level.<br>
   * <br>
   * @return Signal level in percent.
   */
  public long getTxLevel() throws java.lang.Exception {
    return pjsua2JNI.AudioMedia_getTxLevel(swigCPtr, this);
  }

  /**
   * Warning: deprecated and will be removed in future release.<br>
   * <br>
   * Typecast from base class Media. This is useful for application written<br>
   * in language that does not support downcasting such as Python.<br>
   * <br>
   * @param media             The object to be downcasted<br>
   * <br>
   * @return The object as AudioMedia instance
   */
  public static AudioMedia typecastFromMedia(Media media) {
    long cPtr = pjsua2JNI.AudioMedia_typecastFromMedia(Media.getCPtr(media), media);
    return (cPtr == 0) ? null : new AudioMedia(cPtr, false);
  }

  /**
   * Default Constructor.<br>
   * <br>
   * Normally application will not create AudioMedia object directly,<br>
   * but it instantiates an AudioMedia derived class. This is set as public<br>
   * because some STL vector implementations require it.
   */
  public AudioMedia() {
    this(pjsua2JNI.new_AudioMedia(), true);
  }

}
