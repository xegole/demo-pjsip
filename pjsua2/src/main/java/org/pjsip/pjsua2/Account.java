/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.4.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.pjsip.pjsua2;

/**
 * Account.
 */
public class Account {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  protected Account(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(Account obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected static long swigRelease(Account obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        pjsua2JNI.delete_Account(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  protected void swigDirectorDisconnect() {
    swigCMemOwn = false;
    delete();
  }

  public void swigReleaseOwnership() {
    swigCMemOwn = false;
    pjsua2JNI.Account_change_ownership(this, swigCPtr, false);
  }

  public void swigTakeOwnership() {
    swigCMemOwn = true;
    pjsua2JNI.Account_change_ownership(this, swigCPtr, true);
  }

  @SuppressWarnings("this-escape")
  /**
   * Constructor.
   */
  public Account() {
    this(pjsua2JNI.new_Account(), true);
    pjsua2JNI.Account_director_connect(this, swigCPtr, true, true);
  }

  /**
   * Create the account.<br>
   * <br>
   * If application implements a derived class, the derived class should<br>
   * call shutdown() in the beginning stage in its destructor, or<br>
   * alternatively application should call shutdown() before deleting<br>
   * the derived class instance. This is to avoid race condition between<br>
   * the derived class destructor and Account callbacks.<br>
   * <br>
   * @param cfg               The account config.<br>
   * @param make_default      Make this the default account.
   */
  public void create(AccountConfig cfg, boolean make_default) throws java.lang.Exception {
    pjsua2JNI.Account_create__SWIG_0(swigCPtr, this, AccountConfig.getCPtr(cfg), cfg, make_default);
  }

  /**
   * Create the account.<br>
   * <br>
   * If application implements a derived class, the derived class should<br>
   * call shutdown() in the beginning stage in its destructor, or<br>
   * alternatively application should call shutdown() before deleting<br>
   * the derived class instance. This is to avoid race condition between<br>
   * the derived class destructor and Account callbacks.<br>
   * <br>
   * @param cfg               The account config.<br>
   * 
   */
  public void create(AccountConfig cfg) throws java.lang.Exception {
    pjsua2JNI.Account_create__SWIG_1(swigCPtr, this, AccountConfig.getCPtr(cfg), cfg);
  }

  /**
   * Shutdown the account. This will initiate unregistration if needed,<br>
   * and delete the corresponding account in the PJSUA-LIB.<br>
   * <br>
   * Note that application must delete all Buddy instances belong to this<br>
   * account before shutting down the account.<br>
   * <br>
   * If application implements a derived class, the derived class should<br>
   * call this method in the beginning stage in its destructor, or<br>
   * alternatively application should call this method before deleting<br>
   * the derived class instance. This is to avoid race condition between<br>
   * the derived class destructor and Account callbacks.
   */
  public void shutdown() {
    pjsua2JNI.Account_shutdown(swigCPtr, this);
  }

  /**
   * Modify the account to use the specified account configuration.<br>
   * Depending on the changes, this may cause unregistration or<br>
   * reregistration on the account.<br>
   * <br>
   * @param cfg               New account config to be applied to the<br>
   *                          account.
   */
  public void modify(AccountConfig cfg) throws java.lang.Exception {
    pjsua2JNI.Account_modify(swigCPtr, this, AccountConfig.getCPtr(cfg), cfg);
  }

  /**
   * Check if this account is still valid.<br>
   * <br>
   * @return True if it is.
   */
  public boolean isValid() {
    return pjsua2JNI.Account_isValid(swigCPtr, this);
  }

  /**
   * Set this as default account to be used when incoming and outgoing<br>
   * requests don't match any accounts.
   */
  public void setDefault() throws java.lang.Exception {
    pjsua2JNI.Account_setDefault(swigCPtr, this);
  }

  /**
   * Check if this account is the default account. Default account will be<br>
   * used for incoming and outgoing requests that don't match any other<br>
   * accounts.<br>
   * <br>
   * @return True if this is the default account.
   */
  public boolean isDefault() {
    return pjsua2JNI.Account_isDefault(swigCPtr, this);
  }

  /**
   * Get PJSUA-LIB account ID or index associated with this account.<br>
   * <br>
   * @return Integer greater than or equal to zero.
   */
  public int getId() {
    return pjsua2JNI.Account_getId(swigCPtr, this);
  }

  /**
   * Get the Account class for the specified account Id.<br>
   * <br>
   * @param acc_id            The account ID to lookup<br>
   * <br>
   * @return The Account instance or NULL if not found.
   */
  public static Account lookup(int acc_id) {
    long cPtr = pjsua2JNI.Account_lookup(acc_id);
    return (cPtr == 0) ? null : new Account(cPtr, false);
  }

  /**
   * Get account info.<br>
   * <br>
   * @return Account info.
   */
  public AccountInfo getInfo() throws java.lang.Exception {
    return new AccountInfo(pjsua2JNI.Account_getInfo(swigCPtr, this), true);
  }

  /**
   * Send arbitrary requests using the account. Application should only use<br>
   * this function to create auxiliary requests outside dialog, such as<br>
   * OPTIONS, and use the call or presence API to create dialog related<br>
   * requests.<br>
   * <br>
   * <br>
   * 
   */
  public void sendRequest(SendRequestParam prm) throws java.lang.Exception {
    pjsua2JNI.Account_sendRequest(swigCPtr, this, SendRequestParam.getCPtr(prm), prm);
  }

  /**
   * Send response for incoming request that was deferred earlier<br>
   * using DeferredResponse object.<br>
   * <br>
   * @param prm                   The response's parameters.<br>
   * <br>
   * <br>
   * 
   */
  public void sendResponse(SendResponseParam prm) throws java.lang.Exception {
    pjsua2JNI.Account_sendResponse(swigCPtr, this, SendResponseParam.getCPtr(prm), prm);
  }

  /**
   * Update registration or perform unregistration. Application normally<br>
   * only needs to call this function if it wants to manually update the<br>
   * registration or to unregister from the server.<br>
   * <br>
   * @param renew             If False, this will start unregistration<br>
   *                          process.
   */
  public void setRegistration(boolean renew) throws java.lang.Exception {
    pjsua2JNI.Account_setRegistration(swigCPtr, this, renew);
  }

  /**
   * Set or modify account's presence online status to be advertised to<br>
   * remote/presence subscribers. This would trigger the sending of<br>
   * outgoing NOTIFY request if there are server side presence subscription<br>
   * for this account, and/or outgoing PUBLISH if presence publication is<br>
   * enabled for this account.<br>
   * <br>
   * @param pres_st           Presence online status.
   */
  public void setOnlineStatus(PresenceStatus pres_st) throws java.lang.Exception {
    pjsua2JNI.Account_setOnlineStatus(swigCPtr, this, PresenceStatus.getCPtr(pres_st), pres_st);
  }

  /**
   * Lock/bind this account to a specific transport/listener. Normally<br>
   * application shouldn't need to do this, as transports will be selected<br>
   * automatically by the library according to the destination.<br>
   * <br>
   * When account is locked/bound to a specific transport, all outgoing<br>
   * requests from this account will use the specified transport (this<br>
   * includes SIP registration, dialog (call and event subscription), and<br>
   * out-of-dialog requests such as MESSAGE).<br>
   * <br>
   * Note that transport id may be specified in AccountConfig too.<br>
   * <br>
   * @param tp_id             The transport ID.
   */
  public void setTransport(int tp_id) throws java.lang.Exception {
    pjsua2JNI.Account_setTransport(swigCPtr, this, tp_id);
  }

  /**
   * Send NOTIFY to inform account presence status or to terminate server<br>
   * side presence subscription. If application wants to reject the incoming<br>
   * request, it should set the param <i>PresNotifyParam.state</i> to<br>
   * PJSIP_EVSUB_STATE_TERMINATED.<br>
   * <br>
   * @param prm               The sending NOTIFY parameter.
   */
  public void presNotify(PresNotifyParam prm) throws java.lang.Exception {
    pjsua2JNI.Account_presNotify(swigCPtr, this, PresNotifyParam.getCPtr(prm), prm);
  }

  /**
   * Enumerate all buddies of the account.<br>
   * <br>
   * @return The buddy list.
   */
  public BuddyVector2 enumBuddies2() throws java.lang.Exception {
    return new BuddyVector2(pjsua2JNI.Account_enumBuddies2(swigCPtr, this), true);
  }

  /**
   * Find a buddy in the buddy list with the specified URI. <br>
   * <br>
   * Exception: if buddy is not found, PJ_ENOTFOUND will be thrown.<br>
   * <br>
   * @param uri               The buddy URI.<br>
   * <br>
   * @return The pointer to buddy.
   */
  public Buddy findBuddy2(String uri) throws java.lang.Exception {
    return new Buddy(pjsua2JNI.Account_findBuddy2(swigCPtr, this, uri), true);
  }

  /**
   * Notify application on incoming call.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onIncomingCall(OnIncomingCallParam prm) {
    if (getClass() == Account.class) pjsua2JNI.Account_onIncomingCall(swigCPtr, this, OnIncomingCallParam.getCPtr(prm), prm); else pjsua2JNI.Account_onIncomingCallSwigExplicitAccount(swigCPtr, this, OnIncomingCallParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when registration or unregistration has been<br>
   * initiated. Note that this only notifies the initial registration<br>
   * and unregistration. Once registration session is active, subsequent<br>
   * refresh will not cause this callback to be called.<br>
   * <br>
   * @param prm           Callback parameter.
   */
  public void onRegStarted(OnRegStartedParam prm) {
    if (getClass() == Account.class) pjsua2JNI.Account_onRegStarted(swigCPtr, this, OnRegStartedParam.getCPtr(prm), prm); else pjsua2JNI.Account_onRegStartedSwigExplicitAccount(swigCPtr, this, OnRegStartedParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when registration status has changed.<br>
   * Application may then query the account info to get the<br>
   * registration details.<br>
   * <br>
   * @param prm           Callback parameter.
   */
  public void onRegState(OnRegStateParam prm) {
    if (getClass() == Account.class) pjsua2JNI.Account_onRegState(swigCPtr, this, OnRegStateParam.getCPtr(prm), prm); else pjsua2JNI.Account_onRegStateSwigExplicitAccount(swigCPtr, this, OnRegStateParam.getCPtr(prm), prm);
  }

  /**
   * Notification when incoming SUBSCRIBE request is received. Application<br>
   * may use this callback to authorize the incoming subscribe request<br>
   * (e.g. ask user permission if the request should be granted).<br>
   * <br>
   * If this callback is not implemented, all incoming presence subscription<br>
   * requests will be accepted.<br>
   * <br>
   * If this callback is implemented, application has several choices on<br>
   * what to do with the incoming request:<br>
   *  - it may reject the request immediately by specifying non-200 class<br>
   *    final response in the IncomingSubscribeParam.code parameter.<br>
   *  - it may immediately accept the request by specifying 200 as the<br>
   *    IncomingSubscribeParam.code parameter. This is the default value if<br>
   *    application doesn't set any value to the IncomingSubscribeParam.code<br>
   *    parameter. In this case, the library will automatically send NOTIFY<br>
   *    request upon returning from this callback.<br>
   *  - it may delay the processing of the request, for example to request<br>
   *    user permission whether to accept or reject the request. In this<br>
   *    case, the application MUST set the IncomingSubscribeParam.code<br>
   *    argument to 202, then IMMEDIATELY calls presNotify() with<br>
   *    state PJSIP_EVSUB_STATE_PENDING and later calls presNotify()<br>
   *    again to accept or reject the subscription request.<br>
   * <br>
   * Any IncomingSubscribeParam.code other than 200 and 202 will be treated<br>
   * as 200.<br>
   * <br>
   * Application MUST return from this callback immediately (e.g. it must<br>
   * not block in this callback while waiting for user confirmation).<br>
   * <br>
   * @param prm           Callback parameter.
   */
  public void onIncomingSubscribe(OnIncomingSubscribeParam prm) {
    if (getClass() == Account.class) pjsua2JNI.Account_onIncomingSubscribe(swigCPtr, this, OnIncomingSubscribeParam.getCPtr(prm), prm); else pjsua2JNI.Account_onIncomingSubscribeSwigExplicitAccount(swigCPtr, this, OnIncomingSubscribeParam.getCPtr(prm), prm);
  }

  /**
   * Notify application on incoming instant message or pager (i.e. MESSAGE<br>
   * request) that was received outside call context.<br>
   * <br>
   * @param prm           Callback parameter.
   */
  public void onInstantMessage(OnInstantMessageParam prm) {
    if (getClass() == Account.class) pjsua2JNI.Account_onInstantMessage(swigCPtr, this, OnInstantMessageParam.getCPtr(prm), prm); else pjsua2JNI.Account_onInstantMessageSwigExplicitAccount(swigCPtr, this, OnInstantMessageParam.getCPtr(prm), prm);
  }

  /**
   * Notify application about the delivery status of outgoing pager/instant<br>
   * message (i.e. MESSAGE) request.<br>
   * <br>
   * @param prm           Callback parameter.
   */
  public void onInstantMessageStatus(OnInstantMessageStatusParam prm) {
    if (getClass() == Account.class) pjsua2JNI.Account_onInstantMessageStatus(swigCPtr, this, OnInstantMessageStatusParam.getCPtr(prm), prm); else pjsua2JNI.Account_onInstantMessageStatusSwigExplicitAccount(swigCPtr, this, OnInstantMessageStatusParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when a transaction started by Account::sendRequest()<br>
   * has been completed,i.e. when a response has been received.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onSendRequest(OnSendRequestParam prm) {
    if (getClass() == Account.class) pjsua2JNI.Account_onSendRequest(swigCPtr, this, OnSendRequestParam.getCPtr(prm), prm); else pjsua2JNI.Account_onSendRequestSwigExplicitAccount(swigCPtr, this, OnSendRequestParam.getCPtr(prm), prm);
  }

  /**
   * Notify application about typing indication.<br>
   * <br>
   * @param prm           Callback parameter.
   */
  public void onTypingIndication(OnTypingIndicationParam prm) {
    if (getClass() == Account.class) pjsua2JNI.Account_onTypingIndication(swigCPtr, this, OnTypingIndicationParam.getCPtr(prm), prm); else pjsua2JNI.Account_onTypingIndicationSwigExplicitAccount(swigCPtr, this, OnTypingIndicationParam.getCPtr(prm), prm);
  }

  /**
   * Notification about MWI (Message Waiting Indication) status change.<br>
   * This callback can be called upon the status change of the<br>
   * SUBSCRIBE request (for example, 202/Accepted to SUBSCRIBE is received)<br>
   * or when a NOTIFY reqeust is received.<br>
   * <br>
   * @param prm           Callback parameter.
   */
  public void onMwiInfo(OnMwiInfoParam prm) {
    if (getClass() == Account.class) pjsua2JNI.Account_onMwiInfo(swigCPtr, this, OnMwiInfoParam.getCPtr(prm), prm); else pjsua2JNI.Account_onMwiInfoSwigExplicitAccount(swigCPtr, this, OnMwiInfoParam.getCPtr(prm), prm);
  }

}
