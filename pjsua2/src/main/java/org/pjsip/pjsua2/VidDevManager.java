/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.4.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.pjsip.pjsua2;

/**
 * Video device manager.
 */
public class VidDevManager {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  protected VidDevManager(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(VidDevManager obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected static long swigRelease(VidDevManager obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        throw new UnsupportedOperationException("C++ destructor does not have public access");
      }
      swigCPtr = 0;
    }
  }

  /**
   * Initialize the video device subsystem. This will register all supported<br>
   * video device factories to the video device subsystem.<br>
   * <br>
   * By default, library will initialize video device subsystem automatically<br>
   * on library initialization, so application will never need to invoke this<br>
   * function. However, when PJSUA_DONT_INIT_VID_DEV_SUBSYS is set to<br>
   * non-zero, application should invoke this function before accessing<br>
   * video device.
   */
  public void initSubsys() throws java.lang.Exception {
    pjsua2JNI.VidDevManager_initSubsys(swigCPtr, this);
  }

  /**
   * Refresh the list of video devices installed in the system. This function<br>
   * will only refresh the list of video device so all active video streams<br>
   * will be unaffected. After refreshing the device list, application MUST<br>
   * make sure to update all index references to video devices (i.e. all<br>
   * variables of type pjmedia_vid_dev_index) before calling any function<br>
   * that accepts video device index as its parameter.
   */
  public void refreshDevs() throws java.lang.Exception {
    pjsua2JNI.VidDevManager_refreshDevs(swigCPtr, this);
  }

  /**
   * Get the number of video devices installed in the system.<br>
   * <br>
   * @return The number of devices.
   */
  public long getDevCount() {
    return pjsua2JNI.VidDevManager_getDevCount(swigCPtr, this);
  }

  /**
   * Retrieve the video device info for the specified device index.     <br>
   * <br>
   * @param dev_id    The video device id<br>
   * <br>
   * @return The list of video device info
   */
  public VideoDevInfo getDevInfo(int dev_id) throws java.lang.Exception {
    return new VideoDevInfo(pjsua2JNI.VidDevManager_getDevInfo(swigCPtr, this, dev_id), true);
  }

  /**
   * Enum all video devices installed in the system.<br>
   * <br>
   * @return The list of video device info
   */
  public VideoDevInfoVector2 enumDev2() throws java.lang.Exception {
    return new VideoDevInfoVector2(pjsua2JNI.VidDevManager_enumDev2(swigCPtr, this), true);
  }

  /**
   * Lookup device index based on the driver and device name.<br>
   * <br>
   * @param drv_name  The driver name.<br>
   * @param dev_name  The device name.<br>
   * <br>
   * @return The device ID. If the device is not found, <br>
   *                  Error will be thrown.
   */
  public int lookupDev(String drv_name, String dev_name) throws java.lang.Exception {
    return pjsua2JNI.VidDevManager_lookupDev(swigCPtr, this, drv_name, dev_name);
  }

  /**
   * Get string info for the specified capability.<br>
   * <br>
   * @param cap       The capability ID.<br>
   * <br>
   * @return Capability name.
   */
  public String capName(int cap) {
    return pjsua2JNI.VidDevManager_capName(swigCPtr, this, cap);
  }

  /**
   * This will configure video format capability to the video device. <br>
   * If video device is currently active, the method will forward the setting <br>
   * to the video device instance to be applied immediately, if it <br>
   * supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_VID_DEV_CAP_FORMAT capability in VideoDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the video device to be<br>
   * used.<br>
   * <br>
   * @param dev_id    The video device id.    <br>
   * @param format    The video format.<br>
   * @param keep      Specify whether the setting is to be kept for<br>
   *                  future use.
   */
  public void setFormat(int dev_id, MediaFormatVideo format, boolean keep) throws java.lang.Exception {
    pjsua2JNI.VidDevManager_setFormat(swigCPtr, this, dev_id, MediaFormatVideo.getCPtr(format), format, keep);
  }

  /**
   * Get the video format capability to the video device.<br>
   * If video device is currently active, the method will forward the request<br>
   * to the video device. If video device is currently inactive, and if <br>
   * application had previously set the setting and mark the setting as kept, <br>
   * then that setting will be returned. Otherwise, this method will <br>
   * raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_VID_DEV_CAP_FORMAT capability in VideoDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * @param dev_id    The video device id.<br>
   * @return keep     The video format.
   */
  public MediaFormatVideo getFormat(int dev_id) throws java.lang.Exception {
    return new MediaFormatVideo(pjsua2JNI.VidDevManager_getFormat(swigCPtr, this, dev_id), true);
  }

  /**
   * This will configure video format capability to the video device.<br>
   * If video device is currently active, the method will forward the setting<br>
   * to the video device instance to be applied immediately, if it<br>
   * supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_VID_DEV_CAP_INPUT_SCALE capability in VideoDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the video device to be<br>
   * used.<br>
   * <br>
   * @param dev_id    The video device id.<br>
   * @param scale     The video scale.<br>
   * @param keep      Specify whether the setting is to be kept for<br>
   *                  future use.
   */
  public void setInputScale(int dev_id, MediaSize scale, boolean keep) throws java.lang.Exception {
    pjsua2JNI.VidDevManager_setInputScale(swigCPtr, this, dev_id, MediaSize.getCPtr(scale), scale, keep);
  }

  /**
   * Get the video input scale capability to the video device.<br>
   * If video device is currently active, the method will forward the request<br>
   * to the video device. If video device is currently inactive, and if<br>
   * application had previously set the setting and mark the setting as kept,<br>
   * then that setting will be returned. Otherwise, this method will<br>
   * raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_VID_DEV_CAP_FORMAT capability in VideoDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * @param dev_id    The video device id.<br>
   * @return keep     The video format.
   */
  public MediaSize getInputScale(int dev_id) throws java.lang.Exception {
    return new MediaSize(pjsua2JNI.VidDevManager_getInputScale(swigCPtr, this, dev_id), true);
  }

  /**
   * This will configure fast switching to another video device.<br>
   * If video device is currently active, the method will forward the setting<br>
   * to the video device instance to be applied immediately, if it<br>
   * supports it.<br>
   * <br>
   * This method is only valid if the device has <br>
   * PJMEDIA_VID_DEV_CAP_OUTPUT_WINDOW_FLAGS capability in VideoDevInfo.caps <br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the video device to be<br>
   * used.<br>
   * <br>
   * @param dev_id    The video device id.<br>
   * @param flags     The video window flag.<br>
   * @param keep      Specify whether the setting is to be kept for<br>
   *                  future use.
   */
  public void setOutputWindowFlags(int dev_id, int flags, boolean keep) throws java.lang.Exception {
    pjsua2JNI.VidDevManager_setOutputWindowFlags(swigCPtr, this, dev_id, flags, keep);
  }

  /**
   * Get the window output flags capability to the video device.<br>
   * If video device is currently active, the method will forward the request<br>
   * to the video device. If video device is currently inactive, and if<br>
   * application had previously set the setting and mark the setting as kept,<br>
   * then that setting will be returned. Otherwise, this method will<br>
   * raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_VID_DEV_CAP_OUTPUT_WINDOW_FLAGS capability in VideoDevInfo.caps <br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * @param dev_id    The video device id.<br>
   * @return keep     The video format.
   */
  public int getOutputWindowFlags(int dev_id) throws java.lang.Exception {
    return pjsua2JNI.VidDevManager_getOutputWindowFlags(swigCPtr, this, dev_id);
  }

  /**
   * This will configure fast switching to another video device.<br>
   * If video device is currently active, the method will forward the setting<br>
   * to the video device instance to be applied immediately, if it<br>
   * supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_VID_DEV_CAP_SWITCH capability in VideoDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * @param dev_id    The video device id.<br>
   * @param param     The video switch param.
   */
  public void switchDev(int dev_id, VideoSwitchParam param) throws java.lang.Exception {
    pjsua2JNI.VidDevManager_switchDev(swigCPtr, this, dev_id, VideoSwitchParam.getCPtr(param), param);
  }

  /**
   * Check whether the video capture device is currently active, i.e. if<br>
   * a video preview has been started or there is a video call using<br>
   * the device.    <br>
   * <br>
   * @param dev_id    The video device id<br>
   * <br>
   * @return True if it's active.
   */
  public boolean isCaptureActive(int dev_id) {
    return pjsua2JNI.VidDevManager_isCaptureActive(swigCPtr, this, dev_id);
  }

  /**
   * This will configure video orientation of the video capture device.<br>
   * If the device is currently active (i.e. if there is a video call<br>
   * using the device or a video preview has been started), the method<br>
   * will forward the setting to the video device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * The setting will be saved for future opening of the video device,<br>
   * if the "keep" argument is set to true. If the video device is<br>
   * currently inactive, and the "keep" argument is false, this method<br>
   * will throw Error.<br>
   * <br>
   * @param dev_id    The video device id<br>
   * @param orient    The video orientation.<br>
   * @param keep      Specify whether the setting is to be kept for<br>
   *                  future use.
   */
  public void setCaptureOrient(int dev_id, int orient, boolean keep) throws java.lang.Exception {
    pjsua2JNI.VidDevManager_setCaptureOrient__SWIG_0(swigCPtr, this, dev_id, orient, keep);
  }

  /**
   * This will configure video orientation of the video capture device.<br>
   * If the device is currently active (i.e. if there is a video call<br>
   * using the device or a video preview has been started), the method<br>
   * will forward the setting to the video device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * The setting will be saved for future opening of the video device,<br>
   * if the "keep" argument is set to true. If the video device is<br>
   * currently inactive, and the "keep" argument is false, this method<br>
   * will throw Error.<br>
   * <br>
   * @param dev_id    The video device id<br>
   * @param orient    The video orientation.<br>
   * 
   */
  public void setCaptureOrient(int dev_id, int orient) throws java.lang.Exception {
    pjsua2JNI.VidDevManager_setCaptureOrient__SWIG_1(swigCPtr, this, dev_id, orient);
  }

}
